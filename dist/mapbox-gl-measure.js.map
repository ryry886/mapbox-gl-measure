{"version":3,"file":"mapbox-gl-measure.js","sources":["../node_modules/@turf/helpers/dist/es/index.js","../node_modules/@turf/invariant/dist/es/index.js","../node_modules/@turf/meta/dist/es/index.js","../node_modules/@turf/length/dist/es/index.js","../node_modules/@turf/distance/dist/es/index.js","../node_modules/@turf/area/dist/es/index.js","../node_modules/@turf/centroid/dist/es/index.js","../node_modules/@turf/line-segment/dist/es/index.js","../index.js"],"sourcesContent":["/**\n * @module helpers\n */\n/**\n * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.\n *\n * @memberof helpers\n * @type {number}\n */\nexport var earthRadius = 6371008.8;\n/**\n * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var factors = {\n    centimeters: earthRadius * 100,\n    centimetres: earthRadius * 100,\n    degrees: earthRadius / 111325,\n    feet: earthRadius * 3.28084,\n    inches: earthRadius * 39.37,\n    kilometers: earthRadius / 1000,\n    kilometres: earthRadius / 1000,\n    meters: earthRadius,\n    metres: earthRadius,\n    miles: earthRadius / 1609.344,\n    millimeters: earthRadius * 1000,\n    millimetres: earthRadius * 1000,\n    nauticalmiles: earthRadius / 1852,\n    radians: 1,\n    yards: earthRadius * 1.0936,\n};\n/**\n * Units of measurement factors based on 1 meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var unitsFactors = {\n    centimeters: 100,\n    centimetres: 100,\n    degrees: 1 / 111325,\n    feet: 3.28084,\n    inches: 39.37,\n    kilometers: 1 / 1000,\n    kilometres: 1 / 1000,\n    meters: 1,\n    metres: 1,\n    miles: 1 / 1609.344,\n    millimeters: 1000,\n    millimetres: 1000,\n    nauticalmiles: 1 / 1852,\n    radians: 1 / earthRadius,\n    yards: 1.0936133,\n};\n/**\n * Area of measurement factors based on 1 square meter.\n *\n * @memberof helpers\n * @type {Object}\n */\nexport var areaFactors = {\n    acres: 0.000247105,\n    centimeters: 10000,\n    centimetres: 10000,\n    feet: 10.763910417,\n    hectares: 0.0001,\n    inches: 1550.003100006,\n    kilometers: 0.000001,\n    kilometres: 0.000001,\n    meters: 1,\n    metres: 1,\n    miles: 3.86e-7,\n    millimeters: 1000000,\n    millimetres: 1000000,\n    yards: 1.195990046,\n};\n/**\n * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.\n *\n * @name feature\n * @param {Geometry} geometry input geometry\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature} a GeoJSON Feature\n * @example\n * var geometry = {\n *   \"type\": \"Point\",\n *   \"coordinates\": [110, 50]\n * };\n *\n * var feature = turf.feature(geometry);\n *\n * //=feature\n */\nexport function feature(geom, properties, options) {\n    if (options === void 0) { options = {}; }\n    var feat = { type: \"Feature\" };\n    if (options.id === 0 || options.id) {\n        feat.id = options.id;\n    }\n    if (options.bbox) {\n        feat.bbox = options.bbox;\n    }\n    feat.properties = properties || {};\n    feat.geometry = geom;\n    return feat;\n}\n/**\n * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.\n * For GeometryCollection type use `helpers.geometryCollection`\n *\n * @name geometry\n * @param {string} type Geometry Type\n * @param {Array<any>} coordinates Coordinates\n * @param {Object} [options={}] Optional Parameters\n * @returns {Geometry} a GeoJSON Geometry\n * @example\n * var type = \"Point\";\n * var coordinates = [110, 50];\n * var geometry = turf.geometry(type, coordinates);\n * // => geometry\n */\nexport function geometry(type, coordinates, _options) {\n    if (_options === void 0) { _options = {}; }\n    switch (type) {\n        case \"Point\":\n            return point(coordinates).geometry;\n        case \"LineString\":\n            return lineString(coordinates).geometry;\n        case \"Polygon\":\n            return polygon(coordinates).geometry;\n        case \"MultiPoint\":\n            return multiPoint(coordinates).geometry;\n        case \"MultiLineString\":\n            return multiLineString(coordinates).geometry;\n        case \"MultiPolygon\":\n            return multiPolygon(coordinates).geometry;\n        default:\n            throw new Error(type + \" is invalid\");\n    }\n}\n/**\n * Creates a {@link Point} {@link Feature} from a Position.\n *\n * @name point\n * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Point>} a Point feature\n * @example\n * var point = turf.point([-75.343, 39.984]);\n *\n * //=point\n */\nexport function point(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (!coordinates) {\n        throw new Error(\"coordinates is required\");\n    }\n    if (!Array.isArray(coordinates)) {\n        throw new Error(\"coordinates must be an Array\");\n    }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be at least 2 numbers long\");\n    }\n    if (!isNumber(coordinates[0]) || !isNumber(coordinates[1])) {\n        throw new Error(\"coordinates must contain numbers\");\n    }\n    var geom = {\n        type: \"Point\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.\n *\n * @name points\n * @param {Array<Array<number>>} coordinates an array of Points\n * @param {Object} [properties={}] Translate these properties to each Feature\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Point>} Point Feature\n * @example\n * var points = turf.points([\n *   [-75, 39],\n *   [-80, 45],\n *   [-78, 50]\n * ]);\n *\n * //=points\n */\nexport function points(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return point(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.\n *\n * @name polygon\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<Polygon>} Polygon Feature\n * @example\n * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });\n *\n * //=polygon\n */\nexport function polygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {\n        var ring = coordinates_1[_i];\n        if (ring.length < 4) {\n            throw new Error(\"Each LinearRing of a Polygon must have 4 or more Positions.\");\n        }\n        for (var j = 0; j < ring[ring.length - 1].length; j++) {\n            // Check if first point of Polygon contains two numbers\n            if (ring[ring.length - 1][j] !== ring[0][j]) {\n                throw new Error(\"First and last Position are not equivalent.\");\n            }\n        }\n    }\n    var geom = {\n        type: \"Polygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.\n *\n * @name polygons\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection\n * @example\n * var polygons = turf.polygons([\n *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],\n *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],\n * ]);\n *\n * //=polygons\n */\nexport function polygons(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return polygon(coords, properties);\n    }), options);\n}\n/**\n * Creates a {@link LineString} {@link Feature} from an Array of Positions.\n *\n * @name lineString\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<LineString>} LineString Feature\n * @example\n * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});\n * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});\n *\n * //=linestring1\n * //=linestring2\n */\nexport function lineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    if (coordinates.length < 2) {\n        throw new Error(\"coordinates must be an array of two or more positions\");\n    }\n    var geom = {\n        type: \"LineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.\n *\n * @name lineStrings\n * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]\n * associated with the FeatureCollection\n * @param {string|number} [options.id] Identifier associated with the FeatureCollection\n * @returns {FeatureCollection<LineString>} LineString FeatureCollection\n * @example\n * var linestrings = turf.lineStrings([\n *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],\n *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]\n * ]);\n *\n * //=linestrings\n */\nexport function lineStrings(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    return featureCollection(coordinates.map(function (coords) {\n        return lineString(coords, properties);\n    }), options);\n}\n/**\n * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.\n *\n * @name featureCollection\n * @param {Feature[]} features input features\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {FeatureCollection} FeatureCollection of Features\n * @example\n * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});\n * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});\n * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});\n *\n * var collection = turf.featureCollection([\n *   locationA,\n *   locationB,\n *   locationC\n * ]);\n *\n * //=collection\n */\nexport function featureCollection(features, options) {\n    if (options === void 0) { options = {}; }\n    var fc = { type: \"FeatureCollection\" };\n    if (options.id) {\n        fc.id = options.id;\n    }\n    if (options.bbox) {\n        fc.bbox = options.bbox;\n    }\n    fc.features = features;\n    return fc;\n}\n/**\n * Creates a {@link Feature<MultiLineString>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiLineString\n * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiLineString>} a MultiLineString feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);\n *\n * //=multiLine\n */\nexport function multiLineString(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiLineString\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPoint>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPoint\n * @param {Array<Array<number>>} coordinates an array of Positions\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPoint>} a MultiPoint feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPt = turf.multiPoint([[0,0],[10,10]]);\n *\n * //=multiPt\n */\nexport function multiPoint(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPoint\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<MultiPolygon>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name multiPolygon\n * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<MultiPolygon>} a multipolygon feature\n * @throws {Error} if no coordinates are passed\n * @example\n * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);\n *\n * //=multiPoly\n *\n */\nexport function multiPolygon(coordinates, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"MultiPolygon\",\n        coordinates: coordinates,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Creates a {@link Feature<GeometryCollection>} based on a\n * coordinate array. Properties can be added optionally.\n *\n * @name geometryCollection\n * @param {Array<Geometry>} geometries an array of GeoJSON Geometries\n * @param {Object} [properties={}] an Object of key-value pairs to add as properties\n * @param {Object} [options={}] Optional Parameters\n * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature\n * @param {string|number} [options.id] Identifier associated with the Feature\n * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature\n * @example\n * var pt = turf.geometry(\"Point\", [100, 0]);\n * var line = turf.geometry(\"LineString\", [[101, 0], [102, 1]]);\n * var collection = turf.geometryCollection([pt, line]);\n *\n * // => collection\n */\nexport function geometryCollection(geometries, properties, options) {\n    if (options === void 0) { options = {}; }\n    var geom = {\n        type: \"GeometryCollection\",\n        geometries: geometries,\n    };\n    return feature(geom, properties, options);\n}\n/**\n * Round number to precision\n *\n * @param {number} num Number\n * @param {number} [precision=0] Precision\n * @returns {number} rounded number\n * @example\n * turf.round(120.4321)\n * //=120\n *\n * turf.round(120.4321, 2)\n * //=120.43\n */\nexport function round(num, precision) {\n    if (precision === void 0) { precision = 0; }\n    if (precision && !(precision >= 0)) {\n        throw new Error(\"precision must be a positive number\");\n    }\n    var multiplier = Math.pow(10, precision || 0);\n    return Math.round(num * multiplier) / multiplier;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name radiansToLength\n * @param {number} radians in radians across the sphere\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} distance\n */\nexport function radiansToLength(radians, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return radians * factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @name lengthToRadians\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} radians\n */\nexport function lengthToRadians(distance, units) {\n    if (units === void 0) { units = \"kilometers\"; }\n    var factor = factors[units];\n    if (!factor) {\n        throw new Error(units + \" units is invalid\");\n    }\n    return distance / factor;\n}\n/**\n * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet\n *\n * @name lengthToDegrees\n * @param {number} distance in real units\n * @param {string} [units=\"kilometers\"] can be degrees, radians, miles, inches, yards, metres,\n * meters, kilometres, kilometers.\n * @returns {number} degrees\n */\nexport function lengthToDegrees(distance, units) {\n    return radiansToDegrees(lengthToRadians(distance, units));\n}\n/**\n * Converts any bearing angle from the north line direction (positive clockwise)\n * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line\n *\n * @name bearingToAzimuth\n * @param {number} bearing angle, between -180 and +180 degrees\n * @returns {number} angle between 0 and 360 degrees\n */\nexport function bearingToAzimuth(bearing) {\n    var angle = bearing % 360;\n    if (angle < 0) {\n        angle += 360;\n    }\n    return angle;\n}\n/**\n * Converts an angle in radians to degrees\n *\n * @name radiansToDegrees\n * @param {number} radians angle in radians\n * @returns {number} degrees between 0 and 360 degrees\n */\nexport function radiansToDegrees(radians) {\n    var degrees = radians % (2 * Math.PI);\n    return (degrees * 180) / Math.PI;\n}\n/**\n * Converts an angle in degrees to radians\n *\n * @name degreesToRadians\n * @param {number} degrees angle between 0 and 360 degrees\n * @returns {number} angle in radians\n */\nexport function degreesToRadians(degrees) {\n    var radians = degrees % 360;\n    return (radians * Math.PI) / 180;\n}\n/**\n * Converts a length to the requested unit.\n * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet\n *\n * @param {number} length to be converted\n * @param {Units} [originalUnit=\"kilometers\"] of the length\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted length\n */\nexport function convertLength(length, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"kilometers\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(length >= 0)) {\n        throw new Error(\"length must be a positive number\");\n    }\n    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);\n}\n/**\n * Converts a area to the requested unit.\n * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches, hectares\n * @param {number} area to be converted\n * @param {Units} [originalUnit=\"meters\"] of the distance\n * @param {Units} [finalUnit=\"kilometers\"] returned unit\n * @returns {number} the converted area\n */\nexport function convertArea(area, originalUnit, finalUnit) {\n    if (originalUnit === void 0) { originalUnit = \"meters\"; }\n    if (finalUnit === void 0) { finalUnit = \"kilometers\"; }\n    if (!(area >= 0)) {\n        throw new Error(\"area must be a positive number\");\n    }\n    var startFactor = areaFactors[originalUnit];\n    if (!startFactor) {\n        throw new Error(\"invalid original units\");\n    }\n    var finalFactor = areaFactors[finalUnit];\n    if (!finalFactor) {\n        throw new Error(\"invalid final units\");\n    }\n    return (area / startFactor) * finalFactor;\n}\n/**\n * isNumber\n *\n * @param {*} num Number to validate\n * @returns {boolean} true/false\n * @example\n * turf.isNumber(123)\n * //=true\n * turf.isNumber('foo')\n * //=false\n */\nexport function isNumber(num) {\n    return !isNaN(num) && num !== null && !Array.isArray(num);\n}\n/**\n * isObject\n *\n * @param {*} input variable to validate\n * @returns {boolean} true/false\n * @example\n * turf.isObject({elevation: 10})\n * //=true\n * turf.isObject('foo')\n * //=false\n */\nexport function isObject(input) {\n    return !!input && input.constructor === Object;\n}\n/**\n * Validate BBox\n *\n * @private\n * @param {Array<number>} bbox BBox to validate\n * @returns {void}\n * @throws Error if BBox is not valid\n * @example\n * validateBBox([-180, -40, 110, 50])\n * //=OK\n * validateBBox([-180, -40])\n * //=Error\n * validateBBox('Foo')\n * //=Error\n * validateBBox(5)\n * //=Error\n * validateBBox(null)\n * //=Error\n * validateBBox(undefined)\n * //=Error\n */\nexport function validateBBox(bbox) {\n    if (!bbox) {\n        throw new Error(\"bbox is required\");\n    }\n    if (!Array.isArray(bbox)) {\n        throw new Error(\"bbox must be an Array\");\n    }\n    if (bbox.length !== 4 && bbox.length !== 6) {\n        throw new Error(\"bbox must be an Array of 4 or 6 numbers\");\n    }\n    bbox.forEach(function (num) {\n        if (!isNumber(num)) {\n            throw new Error(\"bbox must only contain numbers\");\n        }\n    });\n}\n/**\n * Validate Id\n *\n * @private\n * @param {string|number} id Id to validate\n * @returns {void}\n * @throws Error if Id is not valid\n * @example\n * validateId([-180, -40, 110, 50])\n * //=Error\n * validateId([-180, -40])\n * //=Error\n * validateId('Foo')\n * //=OK\n * validateId(5)\n * //=OK\n * validateId(null)\n * //=Error\n * validateId(undefined)\n * //=Error\n */\nexport function validateId(id) {\n    if (!id) {\n        throw new Error(\"id is required\");\n    }\n    if ([\"string\", \"number\"].indexOf(typeof id) === -1) {\n        throw new Error(\"id must be a number or a string\");\n    }\n}\n","import { isNumber, } from \"@turf/helpers\";\n/**\n * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.\n *\n * @name getCoord\n * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers\n * @returns {Array<number>} coordinates\n * @example\n * var pt = turf.point([10, 10]);\n *\n * var coord = turf.getCoord(pt);\n * //= [10, 10]\n */\nexport function getCoord(coord) {\n    if (!coord) {\n        throw new Error(\"coord is required\");\n    }\n    if (!Array.isArray(coord)) {\n        if (coord.type === \"Feature\" &&\n            coord.geometry !== null &&\n            coord.geometry.type === \"Point\") {\n            return coord.geometry.coordinates;\n        }\n        if (coord.type === \"Point\") {\n            return coord.coordinates;\n        }\n    }\n    if (Array.isArray(coord) &&\n        coord.length >= 2 &&\n        !Array.isArray(coord[0]) &&\n        !Array.isArray(coord[1])) {\n        return coord;\n    }\n    throw new Error(\"coord must be GeoJSON Point or an Array of numbers\");\n}\n/**\n * Unwrap coordinates from a Feature, Geometry Object or an Array\n *\n * @name getCoords\n * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array\n * @returns {Array<any>} coordinates\n * @example\n * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);\n *\n * var coords = turf.getCoords(poly);\n * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]\n */\nexport function getCoords(coords) {\n    if (Array.isArray(coords)) {\n        return coords;\n    }\n    // Feature\n    if (coords.type === \"Feature\") {\n        if (coords.geometry !== null) {\n            return coords.geometry.coordinates;\n        }\n    }\n    else {\n        // Geometry\n        if (coords.coordinates) {\n            return coords.coordinates;\n        }\n    }\n    throw new Error(\"coords must be GeoJSON Feature, Geometry Object or an Array\");\n}\n/**\n * Checks if coordinates contains a number\n *\n * @name containsNumber\n * @param {Array<any>} coordinates GeoJSON Coordinates\n * @returns {boolean} true if Array contains a number\n */\nexport function containsNumber(coordinates) {\n    if (coordinates.length > 1 &&\n        isNumber(coordinates[0]) &&\n        isNumber(coordinates[1])) {\n        return true;\n    }\n    if (Array.isArray(coordinates[0]) && coordinates[0].length) {\n        return containsNumber(coordinates[0]);\n    }\n    throw new Error(\"coordinates must only contain numbers\");\n}\n/**\n * Enforce expectations about types of GeoJSON objects for Turf.\n *\n * @name geojsonType\n * @param {GeoJSON} value any GeoJSON object\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function geojsonType(value, type, name) {\n    if (!type || !name) {\n        throw new Error(\"type and name required\");\n    }\n    if (!value || value.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            value.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link Feature} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name featureOf\n * @param {Feature} feature a feature with an expected geometry type\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} error if value is not the expected type.\n */\nexport function featureOf(feature, type, name) {\n    if (!feature) {\n        throw new Error(\"No feature passed\");\n    }\n    if (!name) {\n        throw new Error(\".featureOf() requires a name\");\n    }\n    if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n        throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n    }\n    if (!feature.geometry || feature.geometry.type !== type) {\n        throw new Error(\"Invalid input to \" +\n            name +\n            \": must be a \" +\n            type +\n            \", given \" +\n            feature.geometry.type);\n    }\n}\n/**\n * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.\n * Internally this uses {@link geojsonType} to judge geometry types.\n *\n * @name collectionOf\n * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged\n * @param {string} type expected GeoJSON type\n * @param {string} name name of calling function\n * @throws {Error} if value is not the expected type.\n */\nexport function collectionOf(featureCollection, type, name) {\n    if (!featureCollection) {\n        throw new Error(\"No featureCollection passed\");\n    }\n    if (!name) {\n        throw new Error(\".collectionOf() requires a name\");\n    }\n    if (!featureCollection || featureCollection.type !== \"FeatureCollection\") {\n        throw new Error(\"Invalid input to \" + name + \", FeatureCollection required\");\n    }\n    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {\n        var feature = _a[_i];\n        if (!feature || feature.type !== \"Feature\" || !feature.geometry) {\n            throw new Error(\"Invalid input to \" + name + \", Feature with geometry required\");\n        }\n        if (!feature.geometry || feature.geometry.type !== type) {\n            throw new Error(\"Invalid input to \" +\n                name +\n                \": must be a \" +\n                type +\n                \", given \" +\n                feature.geometry.type);\n        }\n    }\n}\n/**\n * Get Geometry from Feature or Geometry Object\n *\n * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object\n * @returns {Geometry|null} GeoJSON Geometry Object\n * @throws {Error} if geojson is not a Feature or Geometry Object\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getGeom(point)\n * //={\"type\": \"Point\", \"coordinates\": [110, 40]}\n */\nexport function getGeom(geojson) {\n    if (geojson.type === \"Feature\") {\n        return geojson.geometry;\n    }\n    return geojson;\n}\n/**\n * Get GeoJSON object's type, Geometry type is prioritize.\n *\n * @param {GeoJSON} geojson GeoJSON object\n * @param {string} [name=\"geojson\"] name of the variable to display in error message (unused)\n * @returns {string} GeoJSON type\n * @example\n * var point = {\n *   \"type\": \"Feature\",\n *   \"properties\": {},\n *   \"geometry\": {\n *     \"type\": \"Point\",\n *     \"coordinates\": [110, 40]\n *   }\n * }\n * var geom = turf.getType(point)\n * //=\"Point\"\n */\nexport function getType(geojson, _name) {\n    if (geojson.type === \"FeatureCollection\") {\n        return \"FeatureCollection\";\n    }\n    if (geojson.type === \"GeometryCollection\") {\n        return \"GeometryCollection\";\n    }\n    if (geojson.type === \"Feature\" && geojson.geometry !== null) {\n        return geojson.geometry.type;\n    }\n    return geojson.type;\n}\n","import { feature, lineString, isObject, point } from '@turf/helpers';\n\n/**\n * Callback for coordEach\n *\n * @callback coordEachCallback\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()\n *\n * @name coordEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction coordEach(geojson, callback, excludeWrapCoord) {\n  // Handles null Geometry -- Skips this GeoJSON\n  if (geojson === null) return;\n  var j,\n    k,\n    l,\n    geometry,\n    stopG,\n    coords,\n    geometryMaybeCollection,\n    wrapShrink = 0,\n    coordIndex = 0,\n    isGeometryCollection,\n    type = geojson.type,\n    isFeatureCollection = type === \"FeatureCollection\",\n    isFeature = type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (var featureIndex = 0; featureIndex < stop; featureIndex++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[featureIndex].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {\n      var multiFeatureIndex = 0;\n      var geometryIndex = 0;\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[geomIndex]\n        : geometryMaybeCollection;\n\n      // Handles null Geometry -- Skips this geometry\n      if (geometry === null) continue;\n      coords = geometry.coordinates;\n      var geomType = geometry.type;\n\n      wrapShrink =\n        excludeWrapCoord &&\n        (geomType === \"Polygon\" || geomType === \"MultiPolygon\")\n          ? 1\n          : 0;\n\n      switch (geomType) {\n        case null:\n          break;\n        case \"Point\":\n          if (\n            callback(\n              coords,\n              coordIndex,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n          coordIndex++;\n          multiFeatureIndex++;\n          break;\n        case \"LineString\":\n        case \"MultiPoint\":\n          for (j = 0; j < coords.length; j++) {\n            if (\n              callback(\n                coords[j],\n                coordIndex,\n                featureIndex,\n                multiFeatureIndex,\n                geometryIndex\n              ) === false\n            )\n              return false;\n            coordIndex++;\n            if (geomType === \"MultiPoint\") multiFeatureIndex++;\n          }\n          if (geomType === \"LineString\") multiFeatureIndex++;\n          break;\n        case \"Polygon\":\n        case \"MultiLineString\":\n          for (j = 0; j < coords.length; j++) {\n            for (k = 0; k < coords[j].length - wrapShrink; k++) {\n              if (\n                callback(\n                  coords[j][k],\n                  coordIndex,\n                  featureIndex,\n                  multiFeatureIndex,\n                  geometryIndex\n                ) === false\n              )\n                return false;\n              coordIndex++;\n            }\n            if (geomType === \"MultiLineString\") multiFeatureIndex++;\n            if (geomType === \"Polygon\") geometryIndex++;\n          }\n          if (geomType === \"Polygon\") multiFeatureIndex++;\n          break;\n        case \"MultiPolygon\":\n          for (j = 0; j < coords.length; j++) {\n            geometryIndex = 0;\n            for (k = 0; k < coords[j].length; k++) {\n              for (l = 0; l < coords[j][k].length - wrapShrink; l++) {\n                if (\n                  callback(\n                    coords[j][k][l],\n                    coordIndex,\n                    featureIndex,\n                    multiFeatureIndex,\n                    geometryIndex\n                  ) === false\n                )\n                  return false;\n                coordIndex++;\n              }\n              geometryIndex++;\n            }\n            multiFeatureIndex++;\n          }\n          break;\n        case \"GeometryCollection\":\n          for (j = 0; j < geometry.geometries.length; j++)\n            if (\n              coordEach(geometry.geometries[j], callback, excludeWrapCoord) ===\n              false\n            )\n              return false;\n          break;\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n  }\n}\n\n/**\n * Callback for coordReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback coordReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Array<number>} currentCoord The current coordinate being processed.\n * @param {number} coordIndex The current index of the coordinate being processed.\n * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n */\n\n/**\n * Reduce coordinates in any GeoJSON object, similar to Array.reduce()\n *\n * @name coordReduce\n * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentCoord\n *   //=coordIndex\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentCoord;\n * });\n */\nfunction coordReduce(geojson, callback, initialValue, excludeWrapCoord) {\n  var previousValue = initialValue;\n  coordEach(\n    geojson,\n    function (\n      currentCoord,\n      coordIndex,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex\n    ) {\n      if (coordIndex === 0 && initialValue === undefined)\n        previousValue = currentCoord;\n      else\n        previousValue = callback(\n          previousValue,\n          currentCoord,\n          coordIndex,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    },\n    excludeWrapCoord\n  );\n  return previousValue;\n}\n\n/**\n * Callback for propEach\n *\n * @callback propEachCallback\n * @param {Object} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over properties in any GeoJSON object, similar to Array.forEach()\n *\n * @name propEach\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentProperties, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propEach(features, function (currentProperties, featureIndex) {\n *   //=currentProperties\n *   //=featureIndex\n * });\n */\nfunction propEach(geojson, callback) {\n  var i;\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      for (i = 0; i < geojson.features.length; i++) {\n        if (callback(geojson.features[i].properties, i) === false) break;\n      }\n      break;\n    case \"Feature\":\n      callback(geojson.properties, 0);\n      break;\n  }\n}\n\n/**\n * Callback for propReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback propReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {*} currentProperties The current Properties being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce properties in any GeoJSON object into a single value,\n * similar to how Array.reduce works. However, in this case we lazily run\n * the reduction, so an array of all properties is unnecessary.\n *\n * @name propReduce\n * @param {FeatureCollection|Feature} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {\n *   //=previousValue\n *   //=currentProperties\n *   //=featureIndex\n *   return currentProperties\n * });\n */\nfunction propReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  propEach(geojson, function (currentProperties, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentProperties;\n    else\n      previousValue = callback(previousValue, currentProperties, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Callback for featureEach\n *\n * @callback featureEachCallback\n * @param {Feature<any>} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Iterate over features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name featureEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.featureEach(features, function (currentFeature, featureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n * });\n */\nfunction featureEach(geojson, callback) {\n  if (geojson.type === \"Feature\") {\n    callback(geojson, 0);\n  } else if (geojson.type === \"FeatureCollection\") {\n    for (var i = 0; i < geojson.features.length; i++) {\n      if (callback(geojson.features[i], i) === false) break;\n    }\n  }\n}\n\n/**\n * Callback for featureReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback featureReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name featureReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {\"foo\": \"bar\"}),\n *   turf.point([36, 53], {\"hello\": \"world\"})\n * ]);\n *\n * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   return currentFeature\n * });\n */\nfunction featureReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  featureEach(geojson, function (currentFeature, featureIndex) {\n    if (featureIndex === 0 && initialValue === undefined)\n      previousValue = currentFeature;\n    else previousValue = callback(previousValue, currentFeature, featureIndex);\n  });\n  return previousValue;\n}\n\n/**\n * Get all coordinates from any GeoJSON object.\n *\n * @name coordAll\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @returns {Array<Array<number>>} coordinate position array\n * @example\n * var features = turf.featureCollection([\n *   turf.point([26, 37], {foo: 'bar'}),\n *   turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * var coords = turf.coordAll(features);\n * //= [[26, 37], [36, 53]]\n */\nfunction coordAll(geojson) {\n  var coords = [];\n  coordEach(geojson, function (coord) {\n    coords.push(coord);\n  });\n  return coords;\n}\n\n/**\n * Callback for geomEach\n *\n * @callback geomEachCallback\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()\n *\n * @name geomEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @returns {void}\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n * });\n */\nfunction geomEach(geojson, callback) {\n  var i,\n    j,\n    g,\n    geometry,\n    stopG,\n    geometryMaybeCollection,\n    isGeometryCollection,\n    featureProperties,\n    featureBBox,\n    featureId,\n    featureIndex = 0,\n    isFeatureCollection = geojson.type === \"FeatureCollection\",\n    isFeature = geojson.type === \"Feature\",\n    stop = isFeatureCollection ? geojson.features.length : 1;\n\n  // This logic may look a little weird. The reason why it is that way\n  // is because it's trying to be fast. GeoJSON supports multiple kinds\n  // of objects at its root: FeatureCollection, Features, Geometries.\n  // This function has the responsibility of handling all of them, and that\n  // means that some of the `for` loops you see below actually just don't apply\n  // to certain inputs. For instance, if you give this just a\n  // Point geometry, then both loops are short-circuited and all we do\n  // is gradually rename the input until it's called 'geometry'.\n  //\n  // This also aims to allocate as few resources as possible: just a\n  // few numbers and booleans, rather than any temporary arrays as would\n  // be required with the normalization approach.\n  for (i = 0; i < stop; i++) {\n    geometryMaybeCollection = isFeatureCollection\n      ? geojson.features[i].geometry\n      : isFeature\n      ? geojson.geometry\n      : geojson;\n    featureProperties = isFeatureCollection\n      ? geojson.features[i].properties\n      : isFeature\n      ? geojson.properties\n      : {};\n    featureBBox = isFeatureCollection\n      ? geojson.features[i].bbox\n      : isFeature\n      ? geojson.bbox\n      : undefined;\n    featureId = isFeatureCollection\n      ? geojson.features[i].id\n      : isFeature\n      ? geojson.id\n      : undefined;\n    isGeometryCollection = geometryMaybeCollection\n      ? geometryMaybeCollection.type === \"GeometryCollection\"\n      : false;\n    stopG = isGeometryCollection\n      ? geometryMaybeCollection.geometries.length\n      : 1;\n\n    for (g = 0; g < stopG; g++) {\n      geometry = isGeometryCollection\n        ? geometryMaybeCollection.geometries[g]\n        : geometryMaybeCollection;\n\n      // Handle null Geometry\n      if (geometry === null) {\n        if (\n          callback(\n            null,\n            featureIndex,\n            featureProperties,\n            featureBBox,\n            featureId\n          ) === false\n        )\n          return false;\n        continue;\n      }\n      switch (geometry.type) {\n        case \"Point\":\n        case \"LineString\":\n        case \"MultiPoint\":\n        case \"Polygon\":\n        case \"MultiLineString\":\n        case \"MultiPolygon\": {\n          if (\n            callback(\n              geometry,\n              featureIndex,\n              featureProperties,\n              featureBBox,\n              featureId\n            ) === false\n          )\n            return false;\n          break;\n        }\n        case \"GeometryCollection\": {\n          for (j = 0; j < geometry.geometries.length; j++) {\n            if (\n              callback(\n                geometry.geometries[j],\n                featureIndex,\n                featureProperties,\n                featureBBox,\n                featureId\n              ) === false\n            )\n              return false;\n          }\n          break;\n        }\n        default:\n          throw new Error(\"Unknown Geometry Type\");\n      }\n    }\n    // Only increase `featureIndex` per each feature\n    featureIndex++;\n  }\n}\n\n/**\n * Callback for geomReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback geomReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Geometry} currentGeometry The current Geometry being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {Object} featureProperties The current Feature Properties being processed.\n * @param {Array<number>} featureBBox The current Feature BBox being processed.\n * @param {number|string} featureId The current Feature Id being processed.\n */\n\n/**\n * Reduce geometry in any GeoJSON object, similar to Array.reduce().\n *\n * @name geomReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.point([36, 53], {hello: 'world'})\n * ]);\n *\n * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {\n *   //=previousValue\n *   //=currentGeometry\n *   //=featureIndex\n *   //=featureProperties\n *   //=featureBBox\n *   //=featureId\n *   return currentGeometry\n * });\n */\nfunction geomReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  geomEach(\n    geojson,\n    function (\n      currentGeometry,\n      featureIndex,\n      featureProperties,\n      featureBBox,\n      featureId\n    ) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentGeometry;\n      else\n        previousValue = callback(\n          previousValue,\n          currentGeometry,\n          featureIndex,\n          featureProperties,\n          featureBBox,\n          featureId\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for flattenEach\n *\n * @callback flattenEachCallback\n * @param {Feature} currentFeature The current flattened feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Iterate over flattened features in any GeoJSON object, similar to\n * Array.forEach.\n *\n * @name flattenEach\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n * });\n */\nfunction flattenEach(geojson, callback) {\n  geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {\n    // Callback for single geometry\n    var type = geometry === null ? null : geometry.type;\n    switch (type) {\n      case null:\n      case \"Point\":\n      case \"LineString\":\n      case \"Polygon\":\n        if (\n          callback(\n            feature(geometry, properties, { bbox: bbox, id: id }),\n            featureIndex,\n            0\n          ) === false\n        )\n          return false;\n        return;\n    }\n\n    var geomType;\n\n    // Callback for multi-geometry\n    switch (type) {\n      case \"MultiPoint\":\n        geomType = \"Point\";\n        break;\n      case \"MultiLineString\":\n        geomType = \"LineString\";\n        break;\n      case \"MultiPolygon\":\n        geomType = \"Polygon\";\n        break;\n    }\n\n    for (\n      var multiFeatureIndex = 0;\n      multiFeatureIndex < geometry.coordinates.length;\n      multiFeatureIndex++\n    ) {\n      var coordinate = geometry.coordinates[multiFeatureIndex];\n      var geom = {\n        type: geomType,\n        coordinates: coordinate,\n      };\n      if (\n        callback(feature(geom, properties), featureIndex, multiFeatureIndex) ===\n        false\n      )\n        return false;\n    }\n  });\n}\n\n/**\n * Callback for flattenReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback flattenReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature} currentFeature The current Feature being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n */\n\n/**\n * Reduce flattened features in any GeoJSON object, similar to Array.reduce().\n *\n * @name flattenReduce\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object\n * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var features = turf.featureCollection([\n *     turf.point([26, 37], {foo: 'bar'}),\n *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})\n * ]);\n *\n * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {\n *   //=previousValue\n *   //=currentFeature\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   return currentFeature\n * });\n */\nfunction flattenReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  flattenEach(\n    geojson,\n    function (currentFeature, featureIndex, multiFeatureIndex) {\n      if (\n        featureIndex === 0 &&\n        multiFeatureIndex === 0 &&\n        initialValue === undefined\n      )\n        previousValue = currentFeature;\n      else\n        previousValue = callback(\n          previousValue,\n          currentFeature,\n          featureIndex,\n          multiFeatureIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for segmentEach\n *\n * @callback segmentEachCallback\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n * @returns {void}\n */\n\n/**\n * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //=currentSegment\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   //=segmentIndex\n * });\n *\n * // Calculate the total number of segments\n * var total = 0;\n * turf.segmentEach(polygon, function () {\n *     total++;\n * });\n */\nfunction segmentEach(geojson, callback) {\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    var segmentIndex = 0;\n\n    // Exclude null Geometries\n    if (!feature.geometry) return;\n    // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n    var type = feature.geometry.type;\n    if (type === \"Point\" || type === \"MultiPoint\") return;\n\n    // Generate 2-vertex line segments\n    var previousCoords;\n    var previousFeatureIndex = 0;\n    var previousMultiIndex = 0;\n    var prevGeomIndex = 0;\n    if (\n      coordEach(\n        feature,\n        function (\n          currentCoord,\n          coordIndex,\n          featureIndexCoord,\n          multiPartIndexCoord,\n          geometryIndex\n        ) {\n          // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`\n          if (\n            previousCoords === undefined ||\n            featureIndex > previousFeatureIndex ||\n            multiPartIndexCoord > previousMultiIndex ||\n            geometryIndex > prevGeomIndex\n          ) {\n            previousCoords = currentCoord;\n            previousFeatureIndex = featureIndex;\n            previousMultiIndex = multiPartIndexCoord;\n            prevGeomIndex = geometryIndex;\n            segmentIndex = 0;\n            return;\n          }\n          var currentSegment = lineString(\n            [previousCoords, currentCoord],\n            feature.properties\n          );\n          if (\n            callback(\n              currentSegment,\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex,\n              segmentIndex\n            ) === false\n          )\n            return false;\n          segmentIndex++;\n          previousCoords = currentCoord;\n        }\n      ) === false\n    )\n      return false;\n  });\n}\n\n/**\n * Callback for segmentReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback segmentReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentSegment The current Segment being processed.\n * @param {number} featureIndex The current index of the Feature being processed.\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.\n * @param {number} geometryIndex The current index of the Geometry being processed.\n * @param {number} segmentIndex The current index of the Segment being processed.\n */\n\n/**\n * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()\n * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON\n * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {void}\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n *\n * // Iterate over GeoJSON by 2-vertex segments\n * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {\n *   //= previousSegment\n *   //= currentSegment\n *   //= featureIndex\n *   //= multiFeatureIndex\n *   //= geometryIndex\n *   //= segmentIndex\n *   return currentSegment\n * });\n *\n * // Calculate the total number of segments\n * var initialValue = 0\n * var total = turf.segmentReduce(polygon, function (previousValue) {\n *     previousValue++;\n *     return previousValue;\n * }, initialValue);\n */\nfunction segmentReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  var started = false;\n  segmentEach(\n    geojson,\n    function (\n      currentSegment,\n      featureIndex,\n      multiFeatureIndex,\n      geometryIndex,\n      segmentIndex\n    ) {\n      if (started === false && initialValue === undefined)\n        previousValue = currentSegment;\n      else\n        previousValue = callback(\n          previousValue,\n          currentSegment,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex,\n          segmentIndex\n        );\n      started = true;\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Callback for lineEach\n *\n * @callback lineEachCallback\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,\n * similar to Array.forEach.\n *\n * @name lineEach\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @example\n * var multiLine = turf.multiLineString([\n *   [[26, 37], [35, 45]],\n *   [[36, 53], [38, 50], [41, 55]]\n * ]);\n *\n * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n * });\n */\nfunction lineEach(geojson, callback) {\n  // validation\n  if (!geojson) throw new Error(\"geojson is required\");\n\n  flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {\n    if (feature.geometry === null) return;\n    var type = feature.geometry.type;\n    var coords = feature.geometry.coordinates;\n    switch (type) {\n      case \"LineString\":\n        if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false)\n          return false;\n        break;\n      case \"Polygon\":\n        for (\n          var geometryIndex = 0;\n          geometryIndex < coords.length;\n          geometryIndex++\n        ) {\n          if (\n            callback(\n              lineString(coords[geometryIndex], feature.properties),\n              featureIndex,\n              multiFeatureIndex,\n              geometryIndex\n            ) === false\n          )\n            return false;\n        }\n        break;\n    }\n  });\n}\n\n/**\n * Callback for lineReduce\n *\n * The first time the callback function is called, the values provided as arguments depend\n * on whether the reduce method has an initialValue argument.\n *\n * If an initialValue is provided to the reduce method:\n *  - The previousValue argument is initialValue.\n *  - The currentValue argument is the value of the first element present in the array.\n *\n * If an initialValue is not provided:\n *  - The previousValue argument is the value of the first element present in the array.\n *  - The currentValue argument is the value of the second element present in the array.\n *\n * @callback lineReduceCallback\n * @param {*} previousValue The accumulated value previously returned in the last invocation\n * of the callback, or initialValue, if supplied.\n * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.\n * @param {number} featureIndex The current index of the Feature being processed\n * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed\n * @param {number} geometryIndex The current index of the Geometry being processed\n */\n\n/**\n * Reduce features in any GeoJSON object, similar to Array.reduce().\n *\n * @name lineReduce\n * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object\n * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)\n * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.\n * @returns {*} The value that results from the reduction.\n * @example\n * var multiPoly = turf.multiPolygon([\n *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),\n *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])\n * ]);\n *\n * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n *   //=previousValue\n *   //=currentLine\n *   //=featureIndex\n *   //=multiFeatureIndex\n *   //=geometryIndex\n *   return currentLine\n * });\n */\nfunction lineReduce(geojson, callback, initialValue) {\n  var previousValue = initialValue;\n  lineEach(\n    geojson,\n    function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {\n      if (featureIndex === 0 && initialValue === undefined)\n        previousValue = currentLine;\n      else\n        previousValue = callback(\n          previousValue,\n          currentLine,\n          featureIndex,\n          multiFeatureIndex,\n          geometryIndex\n        );\n    }\n  );\n  return previousValue;\n}\n\n/**\n * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n * Point & MultiPoint will always return null.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.segmentIndex=0] Segment Index\n * @param {Object} [options.properties={}] Translate Properties to output LineString\n * @param {BBox} [options.bbox={}] Translate BBox to output LineString\n * @param {number|string} [options.id={}] Translate Id to output LineString\n * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findSegment(multiLine);\n * // => Feature<LineString<[[10, 10], [50, 30]]>>\n *\n * // First Segment of 2nd Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: 1});\n * // => Feature<LineString<[[-10, -10], [-50, -30]]>>\n *\n * // Last Segment of Last Multi Feature\n * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});\n * // => Feature<LineString<[[-50, -30], [-30, -40]]>>\n */\nfunction findSegment(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var segmentIndex = options.segmentIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find SegmentIndex\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n      if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;\n      return lineString(\n        [coords[segmentIndex], coords[segmentIndex + 1]],\n        properties,\n        options\n      );\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[geometryIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[geometryIndex][segmentIndex],\n          coords[geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (segmentIndex < 0)\n        segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][segmentIndex],\n          coords[multiFeatureIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (segmentIndex < 0)\n        segmentIndex =\n          coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;\n      return lineString(\n        [\n          coords[multiFeatureIndex][geometryIndex][segmentIndex],\n          coords[multiFeatureIndex][geometryIndex][segmentIndex + 1],\n        ],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\n/**\n * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.\n *\n * Negative indexes are permitted.\n *\n * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry\n * @param {Object} [options={}] Optional parameters\n * @param {number} [options.featureIndex=0] Feature Index\n * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index\n * @param {number} [options.geometryIndex=0] Geometry Index\n * @param {number} [options.coordIndex=0] Coord Index\n * @param {Object} [options.properties={}] Translate Properties to output Point\n * @param {BBox} [options.bbox={}] Translate BBox to output Point\n * @param {number|string} [options.id={}] Translate Id to output Point\n * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point\n * @example\n * var multiLine = turf.multiLineString([\n *     [[10, 10], [50, 30], [30, 40]],\n *     [[-10, -10], [-50, -30], [-30, -40]]\n * ]);\n *\n * // First Segment (defaults are 0)\n * turf.findPoint(multiLine);\n * // => Feature<Point<[10, 10]>>\n *\n * // First Segment of the 2nd Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: 1});\n * // => Feature<Point<[-10, -10]>>\n *\n * // Last Segment of last Multi-Feature\n * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});\n * // => Feature<Point<[-30, -40]>>\n */\nfunction findPoint(geojson, options) {\n  // Optional Parameters\n  options = options || {};\n  if (!isObject(options)) throw new Error(\"options is invalid\");\n  var featureIndex = options.featureIndex || 0;\n  var multiFeatureIndex = options.multiFeatureIndex || 0;\n  var geometryIndex = options.geometryIndex || 0;\n  var coordIndex = options.coordIndex || 0;\n\n  // Find FeatureIndex\n  var properties = options.properties;\n  var geometry;\n\n  switch (geojson.type) {\n    case \"FeatureCollection\":\n      if (featureIndex < 0)\n        featureIndex = geojson.features.length + featureIndex;\n      properties = properties || geojson.features[featureIndex].properties;\n      geometry = geojson.features[featureIndex].geometry;\n      break;\n    case \"Feature\":\n      properties = properties || geojson.properties;\n      geometry = geojson.geometry;\n      break;\n    case \"Point\":\n    case \"MultiPoint\":\n      return null;\n    case \"LineString\":\n    case \"Polygon\":\n    case \"MultiLineString\":\n    case \"MultiPolygon\":\n      geometry = geojson;\n      break;\n    default:\n      throw new Error(\"geojson is invalid\");\n  }\n\n  // Find Coord Index\n  if (geometry === null) return null;\n  var coords = geometry.coordinates;\n  switch (geometry.type) {\n    case \"Point\":\n      return point(coords, properties, options);\n    case \"MultiPoint\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      return point(coords[multiFeatureIndex], properties, options);\n    case \"LineString\":\n      if (coordIndex < 0) coordIndex = coords.length + coordIndex;\n      return point(coords[coordIndex], properties, options);\n    case \"Polygon\":\n      if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[geometryIndex].length + coordIndex;\n      return point(coords[geometryIndex][coordIndex], properties, options);\n    case \"MultiLineString\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (coordIndex < 0)\n        coordIndex = coords[multiFeatureIndex].length + coordIndex;\n      return point(coords[multiFeatureIndex][coordIndex], properties, options);\n    case \"MultiPolygon\":\n      if (multiFeatureIndex < 0)\n        multiFeatureIndex = coords.length + multiFeatureIndex;\n      if (geometryIndex < 0)\n        geometryIndex = coords[multiFeatureIndex].length + geometryIndex;\n      if (coordIndex < 0)\n        coordIndex =\n          coords[multiFeatureIndex][geometryIndex].length - coordIndex;\n      return point(\n        coords[multiFeatureIndex][geometryIndex][coordIndex],\n        properties,\n        options\n      );\n  }\n  throw new Error(\"geojson is invalid\");\n}\n\nexport { coordAll, coordEach, coordReduce, featureEach, featureReduce, findPoint, findSegment, flattenEach, flattenReduce, geomEach, geomReduce, lineEach, lineReduce, propEach, propReduce, segmentEach, segmentReduce };\n","import distance from \"@turf/distance\";\nimport { segmentReduce } from \"@turf/meta\";\n/**\n * Takes a {@link GeoJSON} and measures its length in the specified units, {@link (Multi)Point}'s distance are ignored.\n *\n * @name length\n * @param {Feature<LineString|MultiLineString>} geojson GeoJSON to measure\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units=kilometers] can be degrees, radians, miles, or kilometers\n * @returns {number} length of GeoJSON\n * @example\n * var line = turf.lineString([[115, -32], [131, -22], [143, -25], [150, -34]]);\n * var length = turf.length(line, {units: 'miles'});\n *\n * //addToMap\n * var addToMap = [line];\n * line.properties.distance = length;\n */\nexport default function length(geojson, options) {\n    if (options === void 0) { options = {}; }\n    // Calculate distance from 2-vertex line segments\n    return segmentReduce(geojson, function (previousValue, segment) {\n        var coords = segment.geometry.coordinates;\n        return previousValue + distance(coords[0], coords[1], options);\n    }, 0);\n}\n","import { getCoord } from \"@turf/invariant\";\nimport { radiansToLength, degreesToRadians, } from \"@turf/helpers\";\n//http://en.wikipedia.org/wiki/Haversine_formula\n//http://www.movable-type.co.uk/scripts/latlong.html\n/**\n * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.\n * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.\n *\n * @name distance\n * @param {Coord | Point} from origin point or coordinate\n * @param {Coord | Point} to destination point or coordinate\n * @param {Object} [options={}] Optional parameters\n * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers\n * @returns {number} distance between the two points\n * @example\n * var from = turf.point([-75.343, 39.984]);\n * var to = turf.point([-75.534, 39.123]);\n * var options = {units: 'miles'};\n *\n * var distance = turf.distance(from, to, options);\n *\n * //addToMap\n * var addToMap = [from, to];\n * from.properties.distance = distance;\n * to.properties.distance = distance;\n */\nfunction distance(from, to, options) {\n    if (options === void 0) { options = {}; }\n    var coordinates1 = getCoord(from);\n    var coordinates2 = getCoord(to);\n    var dLat = degreesToRadians(coordinates2[1] - coordinates1[1]);\n    var dLon = degreesToRadians(coordinates2[0] - coordinates1[0]);\n    var lat1 = degreesToRadians(coordinates1[1]);\n    var lat2 = degreesToRadians(coordinates2[1]);\n    var a = Math.pow(Math.sin(dLat / 2), 2) +\n        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n    return radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);\n}\nexport default distance;\n","import { geomReduce } from \"@turf/meta\";\n// Note: change RADIUS => earthRadius\nvar RADIUS = 6378137;\n/**\n * Takes one or more features and returns their area in square meters.\n *\n * @name area\n * @param {GeoJSON} geojson input GeoJSON feature(s)\n * @returns {number} area in square meters\n * @example\n * var polygon = turf.polygon([[[125, -15], [113, -22], [154, -27], [144, -15], [125, -15]]]);\n *\n * var area = turf.area(polygon);\n *\n * //addToMap\n * var addToMap = [polygon]\n * polygon.properties.area = area\n */\nexport default function area(geojson) {\n    return geomReduce(geojson, function (value, geom) {\n        return value + calculateArea(geom);\n    }, 0);\n}\n/**\n * Calculate Area\n *\n * @private\n * @param {Geometry} geom GeoJSON Geometries\n * @returns {number} area\n */\nfunction calculateArea(geom) {\n    var total = 0;\n    var i;\n    switch (geom.type) {\n        case \"Polygon\":\n            return polygonArea(geom.coordinates);\n        case \"MultiPolygon\":\n            for (i = 0; i < geom.coordinates.length; i++) {\n                total += polygonArea(geom.coordinates[i]);\n            }\n            return total;\n        case \"Point\":\n        case \"MultiPoint\":\n        case \"LineString\":\n        case \"MultiLineString\":\n            return 0;\n    }\n    return 0;\n}\nfunction polygonArea(coords) {\n    var total = 0;\n    if (coords && coords.length > 0) {\n        total += Math.abs(ringArea(coords[0]));\n        for (var i = 1; i < coords.length; i++) {\n            total -= Math.abs(ringArea(coords[i]));\n        }\n    }\n    return total;\n}\n/**\n * @private\n * Calculate the approximate area of the polygon were it projected onto the earth.\n * Note that this area will be positive if ring is oriented clockwise, otherwise it will be negative.\n *\n * Reference:\n * Robert. G. Chamberlain and William H. Duquette, \"Some Algorithms for Polygons on a Sphere\",\n * JPL Publication 07-03, Jet Propulsion\n * Laboratory, Pasadena, CA, June 2007 https://trs.jpl.nasa.gov/handle/2014/40409\n *\n * @param {Array<Array<number>>} coords Ring Coordinates\n * @returns {number} The approximate signed geodesic area of the polygon in square meters.\n */\nfunction ringArea(coords) {\n    var p1;\n    var p2;\n    var p3;\n    var lowerIndex;\n    var middleIndex;\n    var upperIndex;\n    var i;\n    var total = 0;\n    var coordsLength = coords.length;\n    if (coordsLength > 2) {\n        for (i = 0; i < coordsLength; i++) {\n            if (i === coordsLength - 2) {\n                // i = N-2\n                lowerIndex = coordsLength - 2;\n                middleIndex = coordsLength - 1;\n                upperIndex = 0;\n            }\n            else if (i === coordsLength - 1) {\n                // i = N-1\n                lowerIndex = coordsLength - 1;\n                middleIndex = 0;\n                upperIndex = 1;\n            }\n            else {\n                // i = 0 to N-3\n                lowerIndex = i;\n                middleIndex = i + 1;\n                upperIndex = i + 2;\n            }\n            p1 = coords[lowerIndex];\n            p2 = coords[middleIndex];\n            p3 = coords[upperIndex];\n            total += (rad(p3[0]) - rad(p1[0])) * Math.sin(rad(p2[1]));\n        }\n        total = (total * RADIUS * RADIUS) / 2;\n    }\n    return total;\n}\nfunction rad(num) {\n    return (num * Math.PI) / 180;\n}\n","import { coordEach } from \"@turf/meta\";\nimport { point } from \"@turf/helpers\";\n/**\n * Takes one or more features and calculates the centroid using the mean of all vertices.\n * This lessens the effect of small islands and artifacts when calculating the centroid of a set of polygons.\n *\n * @name centroid\n * @param {GeoJSON} geojson GeoJSON to be centered\n * @param {Object} [options={}] Optional Parameters\n * @param {Object} [options.properties={}] an Object that is used as the {@link Feature}'s properties\n * @returns {Feature<Point>} the centroid of the input features\n * @example\n * var polygon = turf.polygon([[[-81, 41], [-88, 36], [-84, 31], [-80, 33], [-77, 39], [-81, 41]]]);\n *\n * var centroid = turf.centroid(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, centroid]\n */\nfunction centroid(geojson, options) {\n    if (options === void 0) { options = {}; }\n    var xSum = 0;\n    var ySum = 0;\n    var len = 0;\n    coordEach(geojson, function (coord) {\n        xSum += coord[0];\n        ySum += coord[1];\n        len++;\n    }, true);\n    return point([xSum / len, ySum / len], options.properties);\n}\nexport default centroid;\n","import { featureCollection, lineString, } from \"@turf/helpers\";\nimport { getCoords } from \"@turf/invariant\";\nimport { flattenEach } from \"@turf/meta\";\n/**\n * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a\n * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.\n *\n * @name lineSegment\n * @param {GeoJSON} geojson GeoJSON Polygon or LineString\n * @returns {FeatureCollection<LineString>} 2-vertex line segments\n * @example\n * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);\n * var segments = turf.lineSegment(polygon);\n *\n * //addToMap\n * var addToMap = [polygon, segments]\n */\nfunction lineSegment(geojson) {\n    if (!geojson) {\n        throw new Error(\"geojson is required\");\n    }\n    var results = [];\n    flattenEach(geojson, function (feature) {\n        lineSegmentFeature(feature, results);\n    });\n    return featureCollection(results);\n}\n/**\n * Line Segment\n *\n * @private\n * @param {Feature<LineString|Polygon>} geojson Line or polygon feature\n * @param {Array} results push to results\n * @returns {void}\n */\nfunction lineSegmentFeature(geojson, results) {\n    var coords = [];\n    var geometry = geojson.geometry;\n    if (geometry !== null) {\n        switch (geometry.type) {\n            case \"Polygon\":\n                coords = getCoords(geometry);\n                break;\n            case \"LineString\":\n                coords = [getCoords(geometry)];\n        }\n        coords.forEach(function (coord) {\n            var segments = createSegments(coord, geojson.properties);\n            segments.forEach(function (segment) {\n                segment.id = results.length;\n                results.push(segment);\n            });\n        });\n    }\n}\n/**\n * Create Segments from LineString coordinates\n *\n * @private\n * @param {Array<Array<number>>} coords LineString coordinates\n * @param {*} properties GeoJSON properties\n * @returns {Array<Feature<LineString>>} line segments\n */\nfunction createSegments(coords, properties) {\n    var segments = [];\n    coords.reduce(function (previousCoords, currentCoords) {\n        var segment = lineString([previousCoords, currentCoords], properties);\n        segment.bbox = bbox(previousCoords, currentCoords);\n        segments.push(segment);\n        return currentCoords;\n    });\n    return segments;\n}\n/**\n * Create BBox between two coordinates (faster than @turf/bbox)\n *\n * @private\n * @param {Array<number>} coords1 Point coordinate\n * @param {Array<number>} coords2 Point coordinate\n * @returns {BBox} [west, south, east, north]\n */\nfunction bbox(coords1, coords2) {\n    var x1 = coords1[0];\n    var y1 = coords1[1];\n    var x2 = coords2[0];\n    var y2 = coords2[1];\n    var west = x1 < x2 ? x1 : x2;\n    var south = y1 < y2 ? y1 : y2;\n    var east = x1 > x2 ? x1 : x2;\n    var north = y1 > y2 ? y1 : y2;\n    return [west, south, east, north];\n}\nexport default lineSegment;\n","import MapboxDraw from \"@mapbox/mapbox-gl-draw\";\r\nimport length from '@turf/length';\r\nimport area  from '@turf/area';\r\nimport centroid from '@turf/centroid';\r\nimport * as helpers from '@turf/helpers';\r\nimport lineSegment from \"@turf/line-segment\";\r\n\r\nconst MEASURE_LABELS_SOURCE_ID = 'source-measure-labels';\r\nconst MEASURE_LABELS_LAYER_ID = 'layer-measure-labels';\r\nconst MEASURE_POINTS_LAYER_ID = 'layer-measure-points';\r\nconst MEASURE_POINTS_HALO_LAYER_ID = 'layer-measure-points-halo';\r\n\r\nconst SOURCE_DATA = {\r\n  type: \"FeatureCollection\",\r\n  features: []\r\n};\r\nexport default class MapboxMeasure {\r\n\r\n  constructor(options) {\r\n    this.options = options;\r\n    this._drawCtrl = new MapboxDraw({\r\n      displayControlsDefault: false,\r\n      styles: [\r\n        // ACTIVE (being drawn)\r\n        // line stroke\r\n        {\r\n          \"id\": \"gl-draw-line\",\r\n          \"type\": \"line\",\r\n          \"filter\": [\"all\", [\"==\", \"$type\", \"LineString\"],\r\n            [\"!=\", \"mode\", \"static\"]\r\n          ],\r\n          \"layout\": {\r\n            \"line-cap\": \"round\",\r\n            \"line-join\": \"round\"\r\n          },\r\n          \"paint\": {\r\n            \"line-color\": this.options?.style?.lengthStyle?.lineColor ?? \"#D20C0C\",\r\n            \"line-dasharray\": [0.2, 2],\r\n            \"line-width\": this.options?.style?.lengthStyle?.lineWidth ?? 2\r\n          }\r\n        },\r\n        // polygon fill\r\n        {\r\n          \"id\": \"gl-draw-polygon-fill\",\r\n          \"type\": \"fill\",\r\n          \"filter\": [\"all\", [\"==\", \"$type\", \"Polygon\"],\r\n            [\"!=\", \"mode\", \"static\"]\r\n          ],\r\n          \"paint\": {\r\n            \"fill-color\": this.options?.style?.areaStyle?.fillColor ?? \"#D20C0C\",\r\n            \"fill-outline-color\": this.options?.style?.areaStyle?.fillOutlineColor ?? \"#D20C0C\",\r\n            \"fill-opacity\": this.options?.style?.areaStyle?.fillOpacity ?? 0.1,\r\n          }\r\n        },\r\n        // polygon mid points\r\n        {\r\n          'id': 'gl-draw-polygon-midpoint',\r\n          'type': 'circle',\r\n          'filter': ['all',\r\n            ['==', '$type', 'Point'],\r\n            ['==', 'meta', 'midpoint']\r\n          ],\r\n          'paint': {\r\n            'circle-radius': this.options?.style?.pointStyle?.midPointRadius ?? 6,\r\n            'circle-color': this.options?.style?.pointStyle?.midPointColor ?? \"#fbb03b\",\r\n          }\r\n        },\r\n        // polygon outline stroke\r\n        // This doesn't style the first edge of the polygon, which uses the line stroke styling instead\r\n        {\r\n          \"id\": \"gl-draw-polygon-stroke-active\",\r\n          \"type\": \"line\",\r\n          \"filter\": [\"all\", [\"==\", \"$type\", \"Polygon\"],\r\n            [\"!=\", \"mode\", \"static\"]\r\n          ],\r\n          \"layout\": {\r\n            \"line-cap\": \"round\",\r\n            \"line-join\": \"round\"\r\n          },\r\n          \"paint\": {\r\n            \"line-color\": this.options?.style?.areaStyle?.fillOutlineColor ?? \"#D20C0C\",\r\n            \"line-dasharray\": [0.2, 2],\r\n            \"line-width\": this.options?.style?.areaStyle?.lineWidth ?? 2\r\n          }\r\n        },\r\n        // vertex point halos\r\n        {\r\n          \"id\": \"gl-draw-polygon-and-line-vertex-halo-active\",\r\n          \"type\": \"circle\",\r\n          \"filter\": [\"all\", [\"==\", \"meta\", \"vertex\"],\r\n            [\"==\", \"$type\", \"Point\"],\r\n            [\"!=\", \"mode\", \"static\"]\r\n          ],\r\n          \"paint\": {\r\n            \"circle-radius\": this.options?.style?.pointStyle?.midPointHaloRadius ?? 8,\r\n            \"circle-color\": this.options?.style?.pointStyle?.midPointHaloColor ?? '#FFF',\r\n          }\r\n        },\r\n        // vertex points\r\n        {\r\n          \"id\": \"gl-draw-polygon-and-line-vertex-active\",\r\n          \"type\": \"circle\",\r\n          \"filter\": [\"all\", [\"==\", \"meta\", \"vertex\"],\r\n            [\"==\", \"$type\", \"Point\"],\r\n            [\"!=\", \"mode\", \"static\"]\r\n          ],\r\n          \"paint\": {\r\n            \"circle-radius\": this.options?.style?.pointStyle?.midPointRadius ?? 6,\r\n            \"circle-color\": this.options?.style?.pointStyle?.midPointColor ?? \"#fbb03b\",\r\n          }\r\n        },\r\n\r\n        // INACTIVE (static, already drawn)\r\n        // line stroke\r\n        {\r\n          \"id\": \"gl-draw-line-static\",\r\n          \"type\": \"line\",\r\n          \"filter\": [\"all\", [\"==\", \"$type\", \"LineString\"],\r\n            [\"==\", \"mode\", \"static\"]\r\n          ],\r\n          \"layout\": {\r\n            \"line-cap\": \"round\",\r\n            \"line-join\": \"round\"\r\n          },\r\n          \"paint\": {\r\n            \"line-color\": this.options?.style?.lengthStyle?.lineColor ?? \"#D20C0C\",\r\n            \"line-width\": this.options?.style?.lengthStyle?.lineWidth ?? 2\r\n          }\r\n        },\r\n        // polygon fill\r\n        {\r\n          \"id\": \"gl-draw-polygon-fill-static\",\r\n          \"type\": \"fill\",\r\n          \"filter\": [\"all\", [\"==\", \"$type\", \"Polygon\"],\r\n            [\"==\", \"mode\", \"static\"]\r\n          ],\r\n          \"paint\": {\r\n            \"fill-color\": this.options?.style?.areaStyle?.fillColor ?? \"#000\",\r\n            \"fill-outline-color\": this.options?.style?.areaStyle?.fillOutlineColor ?? \"#000\",\r\n            \"fill-opacity\": this.options?.style?.areaStyle?.fillOpacity ?? 0.1,\r\n          }\r\n        },\r\n        // polygon outline\r\n        {\r\n          \"id\": \"gl-draw-polygon-stroke-static\",\r\n          \"type\": \"line\",\r\n          \"filter\": [\"all\", [\"==\", \"$type\", \"Polygon\"],\r\n            [\"==\", \"mode\", \"static\"]\r\n          ],\r\n          \"layout\": {\r\n            \"line-cap\": \"round\",\r\n            \"line-join\": \"round\"\r\n          },\r\n          \"paint\": {\r\n            \"line-color\": this.options?.style?.areaStyle?.fillOutlineColor ?? \"#000\",\r\n            \"line-width\": this.options?.style?.areaStyle?.lineWidth ?? 2\r\n          }\r\n        }\r\n      ]\r\n    });\r\n  }\r\n  start(mode){\r\n    switch(mode){\r\n      case \"distance\":\r\n        this._drawCtrl.changeMode(\"draw_line_string\")\r\n\r\n        break;\r\n      case \"area\":\r\n        this._drawCtrl.changeMode(\"draw_polygon\")\r\n        break;\r\n    }\r\n    this._registerEvents();\r\n  }\r\n  clear(){\r\n    this._drawCtrl.deleteAll();\r\n    this._updateLabels();\r\n  }\r\n  stop(){\r\n    this._drawCtrl.changeMode(\"simple_select\");\r\n    this._removeEvents();\r\n  }\r\n  addTo(map) {\r\n    this._map = map;\r\n    this._addSymbolLayer();\r\n    this._map.addControl(this._drawCtrl);\r\n    this._registerEvents();\r\n    return this;\r\n  }\r\n\r\n  _formatMeasure(dist, isareaStyle = false) {\r\n    return isareaStyle ? this._formatAreaToMetricSystem(dist) : this._formatToMetricSystem(dist);\r\n  }\r\n\r\n  // area in sqm \r\n  _formatAreaToMetricSystem (dist) {\r\n    let measure,unit;\r\n    if(dist <10000){\r\n      measure = dist;\r\n      unit = this.options?.language==\"cn\"?\"\":'m'\r\n    }else if(dist >=10000 && dist <1000000){\r\n      measure = dist/10000;\r\n      unit = this.options?.language==\"cn\"?\"\":'hm'\r\n    }\r\n    else{\r\n      measure = helpers.convertArea(dist,\"meters\",\"kilometers\")\r\n      unit = this.options?.language==\"cn\"?\"\":'km'\r\n    } \r\n    return `${measure.toFixed(2)} ${unit}`\r\n  }\r\n\r\n\r\n  _formatToMetricSystem (dist) {\r\n    let measure,unit;\r\n    if(dist>1000){\r\n      measure = helpers.convertLength(dist,\"meters\",\"kilometers\")\r\n      unit = this.options?.language==\"cn\"?\"\":'km'\r\n    }else{\r\n      measure = dist;\r\n      unit = this.options?.language==\"cn\"?\"\":'m'\r\n    }\r\n    return `${measure.toFixed(2)} ${unit}`\r\n  }\r\n  _addSymbolLayer(){\r\n    this._map.addSource(MEASURE_LABELS_SOURCE_ID, {\r\n      type: 'geojson',\r\n      data: SOURCE_DATA\r\n    });\r\n    this._map.addLayer({\r\n      'id': MEASURE_LABELS_LAYER_ID,\r\n      'type': 'symbol',\r\n      'source': MEASURE_LABELS_SOURCE_ID,\r\n      'layout': {\r\n        // 'text-font': [\r\n        //   'Klokantech Noto Sans Bold'\r\n        // ],\r\n        'text-field': ['get', 'measurement'],\r\n        'text-variable-anchor': ['top', 'bottom', 'left', 'right','center'],\r\n        'text-radial-offset': this.options?.style?.textStyle?.radialOffset?? 0.5,\r\n        'text-justify': 'auto',\r\n        'text-size': this.options?.style?.textStyle?.textSize?? 14,\r\n        'text-letter-spacing': this.options?.style?.textStyle?.letterSpacing?? 0.05,\r\n      },\r\n      'paint': {\r\n        'text-color': this.options?.style?.textStyle?.textColor?? '#D20C0C',\r\n        'text-halo-color': this.options?.style?.textStyle?.textHaloColor?? '#fff',\r\n        'text-halo-width': this.options?.style?.textStyle?.textHaloWidth?? 2,\r\n      },\r\n    });\r\n    this._map.addLayer({\r\n      'id': MEASURE_POINTS_HALO_LAYER_ID,\r\n      'type': 'circle',\r\n      'source': MEASURE_LABELS_SOURCE_ID,\r\n      'filter':  ['==', ['get','visible'], true],\r\n      'layout': {\r\n\r\n        },\r\n        'paint': {\r\n          \"circle-radius\": this.options?.style?.pointStyle?.vertexHaloRadius ?? 4,\r\n          \"circle-color\": this.options?.style?.pointStyle?.vertexHaloColor ?? \"#fff\",\r\n        },\r\n    });\r\n    this._map.addLayer({\r\n      'id': MEASURE_POINTS_LAYER_ID,\r\n      'type': 'circle',\r\n      'source': MEASURE_LABELS_SOURCE_ID,\r\n      'filter':  ['==', ['get','visible'], true],\r\n      'layout': {\r\n        // 'text-font': [\r\n        //   'Klokantech Noto Sans Bold'\r\n        // ],\r\n      },\r\n      'paint': {\r\n        \"circle-radius\": this.options?.style?.pointStyle?.vertexRadius ?? 2,\r\n        \"circle-color\": this.options?.style?.pointStyle?.vertexColor ?? \"#D20C0C\",\r\n      },\r\n    });\r\n  }\r\n  _registerEvents() {\r\n    if(!this._measureListener)\r\n    {\r\n      this._measureListener =this._updateLabels.bind(this)\r\n      this._map.on('draw.create', this._measureListener);\r\n      this._map.on('draw.update', this._measureListener);\r\n      this._map.on('draw.delete', this._measureListener);\r\n      this._map.on('draw.render', this._measureListener);\r\n    }\r\n  }\r\n  _removeEvents(){\r\n    if(this._measureListener){\r\n      this._map.off('draw.create', this._measureListener);\r\n      this._map.off('draw.update', this._measureListener);\r\n      this._map.on('draw.delete', this._measureListener);\r\n      this._map.off('draw.render', this._measureListener);\r\n      this._measureListener = null;\r\n    }\r\n\r\n  }\r\n  _updateLabels() {\r\n    let source = this._map.getSource(MEASURE_LABELS_SOURCE_ID);\r\n    // Build up the centroids for each segment into a features list, containing a property \r\n    // to hold up the measurements\r\n    let features = [];\r\n    // Generate features from what we have on the drawControl:\r\n    let drawnFeatures = this._drawCtrl.getAll();\r\n    drawnFeatures.features.forEach((feature) => {\r\n      try {\r\n        if (feature.geometry.type == 'Polygon') {\r\n          let myarea = this._formatMeasure(area(feature), true);\r\n          let mycentroid = centroid(feature);\r\n          let measurement = `${myarea}`;\r\n          mycentroid.properties = {\r\n            measurement,\r\n          };\r\n          features.push(mycentroid);\r\n        } else if (feature.geometry.type == 'LineString') {\r\n          let segments = lineSegment(feature);\r\n          let lineLength=0\r\n          segments.features.forEach((segment,index) => {\r\n            if(index==0){\r\n              let mycentroid = {\r\n                geometry:{\r\n                  type:\"Point\",\r\n                  coordinates:segment.geometry.coordinates[0]\r\n                },\r\n                properties:{\r\n                  measurement: this.options?.language==\"cn\"?\"\":\"start\",\r\n                  visible:true,\r\n                }\r\n              };\r\n              features.push(mycentroid);\r\n            }\r\n            lineLength += length(segment);\r\n            let measurement = this._formatMeasure(( lineLength* 1000)); //km to m\r\n            let mycentroid = {\r\n              geometry:{\r\n                type:\"Point\",\r\n                coordinates:segment.geometry.coordinates[1]\r\n              },\r\n              properties:{\r\n                measurement:measurement,\r\n                visible:true\r\n              }\r\n            };\r\n            features.push(mycentroid);\r\n          });\r\n        }\r\n      } catch(e) {\r\n         //Silently ignored\r\n      }\r\n      \r\n    });\r\n    let data = {\r\n      type: \"FeatureCollection\",\r\n      features: features\r\n    };\r\n    source.setData(data);\r\n  }\r\n}"],"names":["earthRadius","factors","centimeters","centimetres","degrees","feet","inches","kilometers","kilometres","meters","metres","miles","millimeters","millimetres","nauticalmiles","radians","yards","areaFactors","acres","hectares","feature","geom","properties","options","feat","type","id","bbox","geometry","lineString","coordinates","length","Error","radiansToLength","units","factor","degreesToRadians","Math","PI","convertLength","originalUnit","finalUnit","distance","lengthToRadians","isNumber","num","isNaN","Array","isArray","getCoord","coord","getCoords","coords","coordEach","geojson","callback","excludeWrapCoord","j","k","l","stopG","geometryMaybeCollection","isGeometryCollection","wrapShrink","coordIndex","isFeatureCollection","isFeature","stop","features","featureIndex","geometries","geomIndex","multiFeatureIndex","geometryIndex","geomType","geomEach","i","g","featureProperties","featureBBox","featureId","undefined","flattenEach","coordinate","segmentReduce","initialValue","previousValue","started","segmentIndex","previousCoords","previousFeatureIndex","previousMultiIndex","prevGeomIndex","currentCoord","featureIndexCoord","multiPartIndexCoord","currentSegment","segmentEach","segment","from","to","coordinates1","coordinates2","dLat","dLon","lat1","lat2","a","pow","sin","cos","atan2","sqrt","RADIUS","area","currentGeometry","geomReduce","value","total","polygonArea","calculateArea","abs","ringArea","p1","p2","lowerIndex","middleIndex","upperIndex","coordsLength","rad","centroid","xSum","ySum","len","point","lineSegment","results","forEach","segments","reduce","currentCoords","coords1","coords2","x1","y1","x2","y2","push","createSegments","lineSegmentFeature","fc","featureCollection","MEASURE_LABELS_SOURCE_ID","SOURCE_DATA","MapboxMeasure","_this$options$style$l","_this$options","_this$options$style","_this$options$style$l2","_this$options$style$l3","_this$options2","_this$options2$style","_this$options2$style$","_this$options$style$a","_this$options3","_this$options3$style","_this$options3$style$","_this$options$style$a2","_this$options4","_this$options4$style","_this$options4$style$","_this$options$style$a3","_this$options5","_this$options5$style","_this$options5$style$","_this$options$style$p","_this$options6","_this$options6$style","_this$options6$style$","_this$options$style$p2","_this$options7","_this$options7$style","_this$options7$style$","_this$options$style$a4","_this$options8","_this$options8$style","_this$options8$style$","_this$options$style$a5","_this$options9","_this$options9$style","_this$options9$style$","_this$options$style$p3","_this$options10","_this$options10$style","_this$options10$style2","_this$options$style$p4","_this$options11","_this$options11$style","_this$options11$style2","_this$options$style$p5","_this$options12","_this$options12$style","_this$options12$style2","_this$options$style$p6","_this$options13","_this$options13$style","_this$options13$style2","_this$options$style$l4","_this$options14","_this$options14$style","_this$options14$style2","_this$options$style$l5","_this$options15","_this$options15$style","_this$options15$style2","_this$options$style$a6","_this$options16","_this$options16$style","_this$options16$style2","_this$options$style$a7","_this$options17","_this$options17$style","_this$options17$style2","_this$options$style$a8","_this$options18","_this$options18$style","_this$options18$style2","_this$options$style$a9","_this$options19","_this$options19$style","_this$options19$style2","_this$options$style$a10","_this$options20","_this$options20$style","_this$options20$style2","_classCallCheck","this","_drawCtrl","MapboxDraw","displayControlsDefault","styles","filter","layout","paint","style","lengthStyle","lineColor","lineWidth","areaStyle","fillColor","fillOutlineColor","fillOpacity","pointStyle","midPointRadius","midPointColor","midPointHaloRadius","midPointHaloColor","key","mode","changeMode","_registerEvents","deleteAll","_updateLabels","_removeEvents","map","_map","_addSymbolLayer","addControl","dist","arguments","_formatAreaToMetricSystem","_formatToMetricSystem","measure","unit","_this$options21","language","_this$options22","_this$options23","startFactor","finalFactor","helpers","concat","toFixed","_this$options24","_this$options25","_this$options$style$t","_this$options26","_this$options26$style","_this$options26$style2","_this$options$style$t2","_this$options27","_this$options27$style","_this$options27$style2","_this$options$style$t3","_this$options28","_this$options28$style","_this$options28$style2","_this$options$style$t4","_this$options29","_this$options29$style","_this$options29$style2","_this$options$style$t5","_this$options30","_this$options30$style","_this$options30$style2","_this$options$style$t6","_this$options31","_this$options31$style","_this$options31$style2","_this$options$style$p7","_this$options32","_this$options32$style","_this$options32$style2","_this$options$style$p8","_this$options33","_this$options33$style","_this$options33$style2","_this$options$style$p9","_this$options34","_this$options34$style","_this$options34$style2","_this$options$style$p10","_this$options35","_this$options35$style","_this$options35$style2","addSource","data","addLayer","source","textStyle","radialOffset","textSize","letterSpacing","textColor","textHaloColor","textHaloWidth","vertexHaloRadius","vertexHaloColor","vertexRadius","vertexColor","_measureListener","bind","on","off","_this","getSource","getAll","myarea","_formatMeasure","mycentroid","measurement","lineLength","index","_this$options36","visible","e","setData"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7]}